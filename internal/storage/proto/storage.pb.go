package storagepb

import (
	"context"
	"errors"
	"fmt"
	"sync"
)

// The structs in this file are hand-written equivalents of the code that would normally
// be generated by protoc. They intentionally mirror the Metadata protobufs already
// vendored in the repository so that the storage service can be implemented without
// relying on an external code generator in the execution environment.

// SegmentLocator describes the bucket/object pair used to address a DASH segment.
type SegmentLocator struct {
	Bucket string
	Object string
}

// UploadSegmentHeader carries metadata that accompanies an upload stream.
type UploadSegmentHeader struct {
	SegmentId   string
	Locator     *SegmentLocator
	ContentType string
	SizeBytes   int64
	Checksum    string
	Attributes  map[string]string
	S3Bucket    string
	S3Key       string
}

// ReplicaAck summarises the replication result for a single node.
type ReplicaAck struct {
	NodeId       string
	Success      bool
	ErrorMessage string
}

// UploadSegmentRequest represents either the metadata header or a data chunk.
type UploadSegmentRequest struct {
	payload isUploadSegmentRequest_Payload
}

type isUploadSegmentRequest_Payload interface {
	isUploadSegmentRequest_Payload()
}

type UploadSegmentRequest_Header struct {
	Header *UploadSegmentHeader
}

type UploadSegmentRequest_Chunk struct {
	Chunk []byte
}

type UploadSegmentRequest_Commit struct {
	Commit bool
}

func (*UploadSegmentRequest_Header) isUploadSegmentRequest_Payload() {}
func (*UploadSegmentRequest_Chunk) isUploadSegmentRequest_Payload()  {}
func (*UploadSegmentRequest_Commit) isUploadSegmentRequest_Payload() {}

// NewUploadSegmentRequestHeader constructs a header payload message.
func NewUploadSegmentRequestHeader(header *UploadSegmentHeader) *UploadSegmentRequest {
	return &UploadSegmentRequest{payload: &UploadSegmentRequest_Header{Header: header}}
}

// NewUploadSegmentRequestChunk constructs a data payload message.
func NewUploadSegmentRequestChunk(data []byte) *UploadSegmentRequest {
	return &UploadSegmentRequest{payload: &UploadSegmentRequest_Chunk{Chunk: data}}
}

// NewUploadSegmentRequestCommit constructs a commit marker payload message.
func NewUploadSegmentRequestCommit() *UploadSegmentRequest {
	return &UploadSegmentRequest{payload: &UploadSegmentRequest_Commit{Commit: true}}
}

// GetHeader returns the header if the payload represents metadata.
func (x *UploadSegmentRequest) GetHeader() *UploadSegmentHeader {
	if x == nil {
		return nil
	}
	if h, ok := x.payload.(*UploadSegmentRequest_Header); ok {
		return h.Header
	}
	return nil
}

// GetChunk returns the chunk payload when present.
func (x *UploadSegmentRequest) GetChunk() []byte {
	if x == nil {
		return nil
	}
	if chunk, ok := x.payload.(*UploadSegmentRequest_Chunk); ok {
		return chunk.Chunk
	}
	return nil
}

// GetCommit returns whether the payload marks the end of the client stream.
func (x *UploadSegmentRequest) GetCommit() bool {
	if x == nil {
		return false
	}
	if commit, ok := x.payload.(*UploadSegmentRequest_Commit); ok {
		return commit.Commit
	}
	return false
}

// UploadSegmentResponse summarises the outcome of an upload.
type UploadSegmentResponse struct {
	SizeCommitted int64
	Checksum      string
	ReplicaStatus []*ReplicaAck
}

// GetSegmentRequest requests a segment from the store.
type GetSegmentRequest struct {
	Locator *SegmentLocator
	Offset  int64
	Length  int64
}

// GetSegmentResponse streams the requested data.
type GetSegmentResponse struct {
	Chunk []byte
	Eof   bool
}

// VirtualNode describes the mapping between a token and a physical node.
type VirtualNode struct {
	Id          string
	Token       uint64
	OwnerNodeId string
}

// HeartbeatRequest contains node health information sent periodically.
type HeartbeatRequest struct {
	NodeId           string
	AdvertiseAddress string
	CapacityBytes    int64
	AvailableBytes   int64
	VirtualNodes     []*VirtualNode
	SegmentsServing  int64
}

// HeartbeatResponse acknowledges a heartbeat and communicates cluster directives.
type HeartbeatResponse struct {
	LeaseTtlSeconds  int64
	RequireRebalance bool
	RingVersion      int64
}

// RebalanceRequest allows a node to request updated assignments.
type RebalanceRequest struct {
	NodeId       string
	VirtualNodes []*VirtualNode
	Drain        bool
}

// RebalancePlan captures a re-assignment of virtual nodes.
type RebalancePlan struct {
	PlanId      string
	RingVersion int64
	Assignments []*VirtualNode
}

// RebalanceResponse is returned after a node applies a plan.
type RebalanceResponse struct {
	Plan *RebalancePlan
}

// StorageServiceClient mirrors the generated client interface.
type StorageServiceClient interface {
	UploadSegment(ctx context.Context, opts ...CallOption) (StorageService_UploadSegmentClient, error)
	GetSegment(ctx context.Context, in *GetSegmentRequest, opts ...CallOption) (StorageService_GetSegmentClient, error)
	Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...CallOption) (*HeartbeatResponse, error)
	Rebalance(ctx context.Context, in *RebalanceRequest, opts ...CallOption) (*RebalanceResponse, error)
}

// CallOption mirrors grpc.CallOption but is intentionally empty so the storage
// service can be used with the lightweight grpc stub bundled with the repo.
type CallOption interface{}

// StorageServiceServer is the server API for the storage service.
type StorageServiceServer interface {
	UploadSegment(StorageService_UploadSegmentServer) error
	GetSegment(*GetSegmentRequest, StorageService_GetSegmentServer) error
	Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error)
	Rebalance(context.Context, *RebalanceRequest) (*RebalanceResponse, error)
}

// StorageService_UploadSegmentClient represents the client stream used to upload segments.
type StorageService_UploadSegmentClient interface {
	Send(*UploadSegmentRequest) error
	CloseAndRecv() (*UploadSegmentResponse, error)
	Context() context.Context
}

// StorageService_UploadSegmentServer represents the server side of the upload stream.
type StorageService_UploadSegmentServer interface {
	SendAndClose(*UploadSegmentResponse) error
	Recv() (*UploadSegmentRequest, error)
	Context() context.Context
}

// StorageService_GetSegmentClient streams the response to a GetSegment call.
type StorageService_GetSegmentClient interface {
	Recv() (*GetSegmentResponse, error)
	Context() context.Context
}

// StorageService_GetSegmentServer streams data back to the caller.
type StorageService_GetSegmentServer interface {
	Send(*GetSegmentResponse) error
	Context() context.Context
}

// UnimplementedStorageServiceServer provides forward compatible stubs.
type UnimplementedStorageServiceServer struct{}

func (UnimplementedStorageServiceServer) UploadSegment(StorageService_UploadSegmentServer) error {
	return errors.New("storagepb: UploadSegment not implemented")
}

func (UnimplementedStorageServiceServer) GetSegment(*GetSegmentRequest, StorageService_GetSegmentServer) error {
	return errors.New("storagepb: GetSegment not implemented")
}

func (UnimplementedStorageServiceServer) Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error) {
	return nil, errors.New("storagepb: Heartbeat not implemented")
}

func (UnimplementedStorageServiceServer) Rebalance(context.Context, *RebalanceRequest) (*RebalanceResponse, error) {
	return nil, errors.New("storagepb: Rebalance not implemented")
}

// Below lies a very small in-process transport used primarily in tests. It avoids
// pulling in the full gRPC dependency while still letting the service be exercised.

type localStream struct {
	ctx context.Context
	mu  sync.Mutex
	req []*UploadSegmentRequest
	res *UploadSegmentResponse
	err error
}

func newLocalStream(ctx context.Context) *localStream {
	return &localStream{ctx: ctx}
}

func (s *localStream) Context() context.Context { return s.ctx }

func (s *localStream) Send(req *UploadSegmentRequest) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	if s.err != nil {
		return s.err
	}
	s.req = append(s.req, req)
	return nil
}

func (s *localStream) CloseAndRecv() (*UploadSegmentResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()
	return s.res, s.err
}

func (s *localStream) Recv() (*UploadSegmentRequest, error) {
	s.mu.Lock()
	defer s.mu.Unlock()
	if len(s.req) == 0 {
		return nil, s.err
	}
	req := s.req[0]
	s.req = s.req[1:]
	return req, nil
}

func (s *localStream) SendAndClose(res *UploadSegmentResponse) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	if s.err != nil {
		return s.err
	}
	s.res = res
	return nil
}

// InvokeUploadSegment allows testing the server implementation without a full gRPC stack.
func InvokeUploadSegment(ctx context.Context, srv StorageServiceServer, reqs []*UploadSegmentRequest) (*UploadSegmentResponse, error) {
	stream := newLocalStream(ctx)
	stream.req = append(stream.req, reqs...)
	if err := srv.UploadSegment(stream); err != nil {
		return nil, err
	}
	stream.mu.Lock()
	defer stream.mu.Unlock()
	if stream.err != nil {
		return nil, stream.err
	}
	if stream.res == nil {
		return nil, fmt.Errorf("storagepb: UploadSegment stream closed without response")
	}
	return stream.res, nil
}
